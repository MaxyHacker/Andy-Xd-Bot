"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nhentaiAPIError = exports.API = void 0;
const node_fetch_1 = require("node-fetch");
const doujin_1 = require("./doujin");
const search_1 = require("./search");
const constants_1 = require("./constants");
class API {
    constructor(options = {}) {
        this.options = options;
    }
    fetch(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return node_fetch_1.default(constants_1.API_URL + path)
                .then(res => res.json())
                .then(json => {
                if (json.error)
                    throw new nhentaiAPIError(json, path);
                else
                    return json;
            });
        });
    }
    doujinExists(id) {
        id = Number(id);
        if (isNaN(id))
            throw new TypeError('id is not a number');
        if (id <= 0)
            throw new RangeError('id cannot be lower than 1');
        return node_fetch_1.default(`${constants_1.API_URL}/gallery/${id}`, { method: 'HEAD' }).then(res => {
            switch (res.status) {
                case 200:
                    return true;
                case 404:
                    return false;
                default:
                    throw new Error(`Status code is not a 404 or 200. (${res.status})`);
            }
        });
    }
    fetchDoujin(id) {
        return __awaiter(this, void 0, void 0, function* () {
            id = Number(id);
            if (isNaN(id))
                throw new TypeError('id is not a number');
            if (id <= 0)
                throw new RangeError('id cannot be lower than 1');
            return this.fetch(`/gallery/${id}`)
                .then(data => new doujin_1.Doujin(data))
                .catch(err => {
                var _a;
                if (((_a = err.response) === null || _a === void 0 ? void 0 : _a.error) === 'does not exist')
                    return null;
                throw err;
            });
        });
    }
    fetchHomepage(page = 1, sort = constants_1.SortMethods.RECENT) {
        return this.search('*', page, sort);
    }
    search(query, page = 1, sort = constants_1.SortMethods.RECENT) {
        return __awaiter(this, void 0, void 0, function* () {
            page = Number(page);
            if (isNaN(page))
                throw new TypeError('page is not a number');
            if (!constants_1.SortValues.includes(sort))
                throw new TypeError('sort method is not valid');
            const res = yield this.fetch(`/galleries/search?query=${query}&page=${page}&sort=${sort}`);
            return new search_1.SearchResult(res);
        });
    }
    searchByTagID(id, page = 1, sort = constants_1.SortMethods.RECENT) {
        return __awaiter(this, void 0, void 0, function* () {
            id = Number(id);
            page = Number(page);
            if (isNaN(id))
                throw new TypeError('tagId is not a number');
            if (isNaN(page))
                throw new TypeError('page is not a number');
            if (!constants_1.SortValues.includes(sort))
                throw new TypeError('sort method is not valid');
            const res = yield this.fetch(`/galleries/tagged?tag_id=${id}&page=${page}${sort ? `&sort=${sort}` : ''}`);
            return new search_1.SearchResult(res);
        });
    }
    searchRelated(id, page = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            id = Number(id);
            page = Number(page);
            if (isNaN(id))
                throw new TypeError('doujinID is not a number');
            if (isNaN(page))
                throw new TypeError('page is not a number');
            const res = yield this.fetch(`/gallery/${id}/related`);
            return new search_1.SearchResult(res);
        });
    }
    randomDoujinID() {
        return __awaiter(this, void 0, void 0, function* () {
            return node_fetch_1.default(`${constants_1.HOST_URL}/random`, { method: 'HEAD' }).then(data => {
                const match = data.url.match(/https?:\/\/nhentai\.net\/g\/(\d{1,7})\//);
                if (!match || !match[1])
                    throw new Error('Could not find doujin id in redirect url.');
                return Number(match[1]);
            });
        });
    }
    randomDoujin() {
        return __awaiter(this, void 0, void 0, function* () {
            const id = yield this.randomDoujinID();
            const doujin = yield this.fetchDoujin(id);
            if (!doujin)
                throw new Error('Failed to retrieve doujin that exists. Please try again.');
            return doujin;
        });
    }
}
exports.API = API;
class nhentaiAPIError extends Error {
    constructor(response, url) {
        super(JSON.stringify(response));
        this.response = response;
        this.url = url;
        this.name = 'nhentaiAPIError';
        Error.captureStackTrace(this, nhentaiAPIError);
    }
}
exports.nhentaiAPIError = nhentaiAPIError;
